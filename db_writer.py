# coding=utf-8import scrubberfrom pdb import set_tracefrom db_map import *from scrubber import *session = start_session()# Мапит классы отображения в бдroadmap = {'link': PostsLinkType,           'gallery': PostsGalleryType,           'article': PostsArticleType,           'stream': PostsStreamType,           'main': Posts}# Удаление/добавление подпискиclass Subscribe:    def __init__(self, chat_id, domain_id=None, domain_prefix=None):        self.chat_id = chat_id        self.domain_id = domain_id        self.domain_prefix = domain_prefix    # Удалить подписку пользователя    def delete(self):        session.query(UsersToDomains). \            filter_by(chat_id=self.chat_id, domain_prefix=self.domain_prefix). \            delete(synchronize_session=False)        session.commit()        return True    # Добавить подписку пользователя на обновления подсайта    def add(self):        set_relation = UsersToDomains({'chat_id': self.chat_id,                                       'domain_id': self.domain_id,                                       'domain_prefix': self.domain_prefix})        session.add(set_relation)        session.commit()        return True    # Существует ли подписка    def is_exist(self):        relation = session.query(UsersToDomains). \            filter_by(chat_id=self.chat_id, domain_prefix=self.domain_prefix).first()        return True if getattr(relation, 'chat_id', None) else Falseclass Tracking:    def __init__(self, domain_id=None, domain_prefix=None, last_id=None):        self.domain_id = domain_id        self.domain_prefix = domain_prefix        self.last_id = last_id    # Удалить подсайт из отслеживаемых если его нет в таблице подписок    def delete(self):        domain = session.query(UsersToDomains).filter_by(domain_prefix=self.domain_prefix).first()        if getattr(domain, 'domain_prefix', None) is not None:            return True        else:            session.query(TracedDomains) \                .filter_by(prefix=self.domain_prefix). \                delete(synchronize_session=False)            session.commit()            return True    # Добавить подсайт в отслеживаемые    def add(self):        Update(domain_name=self.domain_prefix).db_update_posts()        self.last_id = Domain(domain_prefix=self.domain_prefix).get_last_id()        set_domain = TracedDomains({'domain_id': self.domain_id,                                    'prefix': self.domain_prefix,                                    'last_id': self.last_id})        session.add(set_domain)        session.commit()        return True    def chandge_last_id(self):        domain = session.query(TracedDomains).filter_by(prefix=self.domain_prefix).first()        domain.last_id = self.last_id        session.commit()        return True    # Есть ли домен в отсеживаемых    def is_exist(self):        traced = session.query(TracedDomains). \            filter_by(domain_id=self.domain_id).first()        return True if getattr(traced, 'domain_id', None) else False    # Возвращает список отслеживаемых подсайтов    @staticmethod    def traced_domains():        domain_list = []        for domain in session.query(TracedDomains):            domain_list.append(domain.prefix)        return domain_list# Пользовательские методыclass User:    def __init__(self, chat_id, ctype=None, firstname=None, lastname=None, username=None):        self.chat_id = chat_id        self.ctype = ctype        self.firstname = firstname        self.lastname = lastname        self.username = username    # Удалить пользователя из базы    def delete(self):        session.query(Users).filter_by(chat_id=self.chat_id). \            delete(synchronize_session=False)        session.commit()        return True    # Добавить пользователя в базу    def add(self):        set_user = Users({'chat_id': self.chat_id, 'type': self.ctype, 'firstname': self.firstname,                          'lastname': self.lastname, 'username': self.username})        session.add(set_user)        session.commit()        return True    # Существует ли пользователь    def is_exist(self):        by_chat_id = session.query(Users).filter_by(chat_id=self.chat_id).first()        return True if getattr(by_chat_id, 'chat_id', None) else False    def traced_domains(self):        return [domain.prefix for domain in session.query(Subscribe).filter_by(chat_id=self.chat_id)]    def subscribes(self):        return [subscribe.domain_prefix for subscribe in session.query(UsersToDomains).filter_by(chat_id=self.chat_id)]# Обновление бдclass Update:    def __init__(self, domain_name=None, post_id=None):        self.domain_name = domain_name        self.post_id = post_id    # Обновить значение last_id в TracedDomains    def db_update_last_id(self):        domain = session.query(TracedDomains).filter_by(prefix=self.domain_name).first()        domain.last_id = self.post_id        session.commit()        return True    # Обновляет список посайтов    @staticmethod    def db_update_domains():        domains = DomainsScrubber()        for domain in domains.data:            try:                domain = Domains(domain)                session.add(domain)                session.commit()            except psycopg2.IntegrityError:                session.close()        return True    # Удалить кэш таблицы с постами    @staticmethod    def delete_tables():        for val in roadmap.values():            session.query(val).delete(synchronize_session=False)        session.commit()    # Обновляет список постов для self.domain    def db_update_posts(self):        has_updates = False        def additional_data(data, p_type):            additional = p_type(data)            session.add(additional)        # Получает для выбранного подсайта посты с сервера d3        posts = scrubber.PostScrubber(self.domain_name).data        # Получает последний поста для выбранного подсайта        last = session.query(TracedDomains).filter_by(prefix=self.domain_name).first()        try:            last.last_id        except AttributeError:            class Object(object):                pass            last = Object()            setattr(last, 'last_id', 0)        # Цикл прохода по постам, запускает функцию main записи в базу если один из id старше последнего        for post in reversed(posts):            post_type = post[1]['type']            post_id = int(post[1]['id'])            post_main = post[1]            post_additional = post[2]            if post_id > last.last_id:                has_updates = True                p = Posts(post_main)                session.add(p)                session.commit()                additional_data(post_additional, roadmap[post_type])        # Транзакция в базу        session.commit()        return has_updates# Методы подсайтовclass Domain:    def __init__(self, domain_prefix=None, post_id=None):        self.domain_prefix = domain_prefix        self.post_id = post_id    # Возвращает итератор новых постов для подсайта    def get_new_posts(self):        def additional(pid, post_type):            for post_additional in session.query(post_type).filter_by(post_id=pid):                return post_additional        for post in session.query(Posts).filter_by(domain_prefix=self.domain_prefix).order_by(Posts.id):            post2 = additional(post.id, roadmap[post.type])            yield post, post2    # Возвращает список юзеров для подсайта    def subscribers(self):        user_list = []        domain = session.query(Domains).filter_by(prefix=self.domain_prefix).first()        for user_domain in session.query(UsersToDomains).filter_by(domain_id=domain.id):            user_list.append(user_domain.chat_id)        return user_list    # Возвращает last_id для подсайта    def get_last_id(self):        last = session.query(Posts). \            filter_by(domain_prefix=self.domain_prefix). \            order_by(Posts.id.desc()). \            first()        return last.id    # Существует ли домен    def is_exist(self):        domain = session.query(Domains).filter_by(prefix=self.domain_prefix).first()        return True if getattr(domain, 'id', None) else False    # Получить id по имени    def id_num(self):        domain = session.query(Domains).filter_by(prefix=self.domain_prefix).first()        return getattr(domain, 'id', None)Update(domain_name='cyberpunk', post_id=1561247).db_update_last_id()